// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package siemensdescommons.actions;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import com.siemens.plm.sdk.client.ApiResponse;
import com.siemens.plm.sdk.client.IApiClient;
import com.siemens.plm.sdk.internal.ApiClient;
import com.siemens.plm.sdk.runtime.BasicCredentials;
import com.siemens.plm.sdk.runtime.ClientConfig;
import com.siemens.plm.sdk.runtime.IClientConfig;
import com.siemens.plm.sdk.runtime.ICredentials;
import com.siemens.plm.webapp.strategies.IConfigStrategy;
import siemenssamauthssomodule.actions.custom.MendixStartupConfig;
import siemenssamauthssomodule.proxies.SessionData;
import siemenssamauthssomodule.proxies.microflows.Microflows;

public class InvokeDESApi extends CustomJavaAction<java.lang.String>
{
	private siemensdescommons.proxies.HttpMethod httpMethod;
	private java.lang.String baseUri;
	private java.lang.String apiPath;
	private java.lang.String requestBody;
	private java.lang.String outputDataPath;
	private java.lang.String accessKeyId;
	private java.lang.String secretAccessKey;

	public InvokeDESApi(IContext context, java.lang.String httpMethod, java.lang.String baseUri, java.lang.String apiPath, java.lang.String requestBody, java.lang.String outputDataPath, java.lang.String accessKeyId, java.lang.String secretAccessKey)
	{
		super(context);
		this.httpMethod = httpMethod == null ? null : siemensdescommons.proxies.HttpMethod.valueOf(httpMethod);
		this.baseUri = baseUri;
		this.apiPath = apiPath;
		this.requestBody = requestBody;
		this.outputDataPath = outputDataPath;
		this.accessKeyId = accessKeyId;
		this.secretAccessKey = secretAccessKey;
	}

	@java.lang.Override
	public java.lang.String executeAction() throws Exception
	{
		// BEGIN USER CODE

		final String currentAccessKeyId;
        final String currentSecretAccessKey;

        // if an access key was passed in, use it; otherwise, use the one from the session
        if (accessKeyId != null && !accessKeyId.trim().isEmpty() && secretAccessKey != null && !secretAccessKey.trim().isEmpty()) {
            currentAccessKeyId = accessKeyId.trim();
            currentSecretAccessKey = secretAccessKey.trim();
        } else {
            // get mendix configuration stratgey
            final IConfigStrategy configStrategy = MendixStartupConfig.getInstance().getConfigStrategy();

            // check if SAM Auth authentication can be skipped
            final boolean skipSAMAuth = Boolean.parseBoolean((String) configStrategy.getConfig("skipSamAuth"));

            // if SAM Auth authentication can be skipped, extract access key & user info from config;
            // otherwise, extract access key & user info from session
            if (skipSAMAuth) {
                currentAccessKeyId = (String) configStrategy.getConfig("_devAccessKeyId");
                currentSecretAccessKey = (String) configStrategy.getConfig("_devSecretAccessKey");
            } else {
                final SessionData sessionData = Microflows.mF_GetSessionData(getContext());
                currentAccessKeyId = sessionData.getaccessKeyId();
                currentSecretAccessKey = sessionData.getsecretAccessKey();
            }
        }

        // construct client config
        final ICredentials credentials = new BasicCredentials(currentAccessKeyId, currentSecretAccessKey);
        final IClientConfig clientConfig = new ClientConfig(credentials);
        clientConfig.setServiceUrl(baseUri);

        // invoke API
        final IApiClient apiClient = new ApiClient(clientConfig);
        final ObjectMapper mapper = new ObjectMapper();
        final JsonNode jsonInput;
        if (requestBody != null && !requestBody.trim().isEmpty()) {
            jsonInput = mapper.readTree(requestBody);
        } else {
            jsonInput = null;
        }
        final String fullUri = baseUri + apiPath;
        @SuppressWarnings("rawtypes")
        ApiResponse response = apiClient.send(fullUri, httpMethod.getCaption(), null, jsonInput);

        // construct Mendix object from response
        if (response.getStatusCode() >= 200 && response.getStatusCode() <= 299) {
            final JsonNode jsonObj = (JsonNode) response.getData();
            JsonNode jsonResult = jsonObj;
            if (outputDataPath != null && !outputDataPath.trim().isEmpty()) {
                jsonResult = jsonObj.at(outputDataPath.trim());
            }
            final String jsonString = mapper.writeValueAsString(jsonResult);

            return jsonString;
        } else {
            throw new Exception((String) response.getData());
        }

		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "InvokeDESApi";
	}

	// BEGIN EXTRA CODE
	// END EXTRA CODE
}
